<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GD Wave - jax.fun</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }

        /* Navigation */
        .navbar {
            padding: 15px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: rgba(0,0,0,0.5);
        }
        .back-home {
            color: rgba(255,255,255,0.7);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 700;
            transition: all 0.2s;
        }
        .back-home:hover { color: #fff; }
        .game-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        /* Screens */
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 70px 20px 20px;
        }
        .screen.active { display: flex; }

        /* Menu Screen */
        .menu-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(135deg, #00ffff, #ff00ff, #00ffff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0,255,255,0.5);
        }
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .menu-subtitle {
            color: #888;
            margin-bottom: 40px;
            font-size: 1.1rem;
        }

        /* Level Select */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            max-width: 900px;
            width: 100%;
            padding: 0 20px;
        }
        .level-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        .level-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: 0.5s;
        }
        .level-card:hover::before { left: 100%; }
        .level-card:hover {
            transform: translateY(-5px);
            border-color: var(--level-color, #00ffff);
            box-shadow: 0 10px 40px rgba(0,255,255,0.3);
        }
        .level-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--level-color, #00ffff);
        }
        .level-difficulty {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
        }
        .star {
            width: 16px;
            height: 16px;
            background: var(--level-color, #00ffff);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
        }
        .star.empty { opacity: 0.2; }
        .level-desc {
            color: #888;
            font-size: 0.9rem;
        }
        .level-best {
            margin-top: 10px;
            font-size: 0.85rem;
            color: #666;
        }
        .level-best span { color: #0f0; }

        /* Game Screen */
        #game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #game-canvas {
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(0,255,255,0.3);
        }
        .game-hud {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 40px;
            font-family: 'Orbitron', sans-serif;
            z-index: 10;
        }
        .hud-item {
            text-align: center;
        }
        .hud-label {
            font-size: 0.7rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .hud-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        /* Progress bar */
        .progress-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            z-index: 10;
        }
        .progress-bar {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            border-radius: 4px;
            transition: width 0.1s;
        }
        .progress-text {
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }

        /* Start overlay */
        .start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .start-overlay.hidden { display: none; }
        .start-level-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 20px;
            color: var(--level-color, #00ffff);
            text-shadow: 0 0 20px var(--level-color, #00ffff);
        }
        .start-text {
            font-size: 1.2rem;
            color: #888;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Game Over / Complete */
        .result-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 60;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .result-overlay.active { display: flex; }
        .result-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: 900;
            margin-bottom: 15px;
        }
        .result-title.fail { color: #ff4444; text-shadow: 0 0 30px #ff4444; }
        .result-title.complete { color: #00ff00; text-shadow: 0 0 30px #00ff00; }
        .result-stats {
            margin-bottom: 30px;
            text-align: center;
        }
        .result-stat {
            font-size: 1.1rem;
            color: #888;
            margin: 5px 0;
        }
        .result-stat span { color: #fff; font-weight: 700; }
        .btn-group {
            display: flex;
            gap: 15px;
        }
        .btn {
            font-family: 'Orbitron', sans-serif;
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 14px 32px;
            font-size: 1rem;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px rgba(0,255,255,0.5);
        }
        .btn-secondary {
            border-color: #666;
            color: #666;
        }
        .btn-secondary:hover {
            background: #666;
            color: #fff;
            box-shadow: none;
        }

        /* Attempt counter */
        .attempts {
            position: fixed;
            top: 70px;
            right: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: #666;
            z-index: 10;
        }

        /* Sound toggle */
        .sound-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255,255,255,0.1);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            z-index: 100;
            transition: all 0.3s;
        }
        .sound-toggle:hover {
            background: rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <a href="../../../index.html" class="back-home">‚Üê Back to jax.fun</a>
        <span class="game-name">GD WAVE</span>
    </nav>

    <button class="sound-toggle" id="sound-toggle">üîä</button>

    <!-- Menu Screen -->
    <div id="menu-screen" class="screen active">
        <h1 class="menu-title">GD WAVE</h1>
        <p class="menu-subtitle">Geometry Dash Wave Mode Clone</p>

        <div class="level-grid" id="level-grid"></div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="screen">
        <div class="game-hud">
            <div class="hud-item">
                <div class="hud-label">Progress</div>
                <div class="hud-value" id="progress-display">0%</div>
            </div>
        </div>

        <div class="attempts" id="attempts">Attempt 1</div>

        <div id="game-container">
            <canvas id="game-canvas"></canvas>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="level-name-display">Level Name</div>
        </div>

        <div class="start-overlay" id="start-overlay">
            <div class="start-level-name" id="start-level-name">Level Name</div>
            <div class="start-text">Click or Press Space to Start</div>
        </div>
    </div>

    <!-- Result Overlay -->
    <div class="result-overlay" id="result-overlay">
        <div class="result-title" id="result-title">Level Complete!</div>
        <div class="result-stats">
            <div class="result-stat">Progress: <span id="result-progress">100%</span></div>
            <div class="result-stat">Attempts: <span id="result-attempts">1</span></div>
        </div>
        <div class="btn-group">
            <button class="btn" id="retry-btn">Retry</button>
            <button class="btn btn-secondary" id="menu-btn">Menu</button>
        </div>
    </div>

    <script>
        // ============ SOUND EFFECTS (Freesound.org) ============
        const sounds = {
            music: new Audio('https://cdn.freesound.org/previews/685/685539_13091475-hq.mp3'),
            death: new Audio('https://cdn.freesound.org/previews/533/533034_6299573-hq.mp3'),
            complete: new Audio('https://cdn.freesound.org/previews/270/270528_5123851-hq.mp3'),
            click: new Audio('https://cdn.freesound.org/previews/421/421324_3387258-hq.mp3')
        };

        // Configure sounds
        sounds.music.loop = true;
        sounds.music.volume = 0.4;
        sounds.death.volume = 0.6;
        sounds.complete.volume = 0.7;
        sounds.click.volume = 0.5;

        let soundEnabled = true;
        const soundToggle = document.getElementById('sound-toggle');
        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.textContent = soundEnabled ? 'üîä' : 'üîá';
            if (!soundEnabled) {
                sounds.music.pause();
            }
        });

        function playSound(name) {
            if (!soundEnabled) return;
            const sound = sounds[name];
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(() => {});
            }
        }

        // ============ LEVEL DEFINITIONS ============
        const LEVELS = [
            {
                id: 'tutorial',
                name: 'Wave Basics',
                color: '#00ff88',
                difficulty: 1,
                desc: 'Learn the wave controls',
                speed: 6,
                generateObstacles: generateTutorial
            },
            {
                id: 'corridors',
                name: 'Tight Corridors',
                color: '#00ffff',
                difficulty: 2,
                desc: 'Navigate through narrow paths',
                speed: 7,
                generateObstacles: generateCorridors
            },
            {
                id: 'nine_circles',
                name: 'Nine Circles',
                color: '#ff00ff',
                difficulty: 4,
                desc: 'Classic NC-style wave section',
                speed: 8,
                generateObstacles: generateNineCircles
            },
            {
                id: 'sonic_wave',
                name: 'Sonic Wave',
                color: '#00aaff',
                difficulty: 5,
                desc: 'Inspired by the legendary level',
                speed: 9,
                generateObstacles: generateSonicWave
            },
            {
                id: 'bloodbath',
                name: 'Bloodbath',
                color: '#ff4444',
                difficulty: 5,
                desc: 'The iconic demon wave section',
                speed: 9,
                generateObstacles: generateBloodbath
            },
            {
                id: 'sakupen',
                name: 'Sakupen Hell',
                color: '#ff0088',
                difficulty: 5,
                desc: 'Extreme precision required',
                speed: 10,
                generateObstacles: generateSakupen
            }
        ];

        // ============ OBSTACLE GENERATORS ============
        function generateTutorial(canvasHeight) {
            const obstacles = [];
            const groundH = 30;
            let x = 600;

            for (let i = 0; i < 8; i++) {
                obstacles.push({ x, y: 0, w: 200, h: 100, type: 'block' });
                obstacles.push({ x, y: canvasHeight - groundH - 100, w: 200, h: 100, type: 'block' });
                x += 400;

                if (i % 2 === 0) {
                    obstacles.push({ x, y: 0, w: 200, h: 180, type: 'block' });
                    obstacles.push({ x, y: canvasHeight - groundH - 80, w: 200, h: 80, type: 'block' });
                } else {
                    obstacles.push({ x, y: 0, w: 200, h: 80, type: 'block' });
                    obstacles.push({ x, y: canvasHeight - groundH - 180, w: 200, h: 180, type: 'block' });
                }
                x += 400;
            }

            return { obstacles, length: x + 300 };
        }

        function generateCorridors(canvasHeight) {
            const obstacles = [];
            const groundH = 30;
            const gapSize = 110;
            let x = 600;

            for (let i = 0; i < 15; i++) {
                const centerY = 150 + Math.sin(i * 0.5) * 100;
                obstacles.push({ x, y: 0, w: 150, h: centerY - gapSize/2, type: 'block' });
                obstacles.push({ x, y: centerY + gapSize/2, w: 150, h: canvasHeight - groundH - (centerY + gapSize/2), type: 'block' });
                x += 200;
            }

            for (let i = 0; i < 10; i++) {
                const spikeY = i % 2 === 0 ? canvasHeight - groundH - 40 : 0;
                obstacles.push({ x, y: spikeY, w: 40, h: 40, type: 'spike', direction: i % 2 === 0 ? 'up' : 'down' });
                x += 120;
            }

            return { obstacles, length: x + 300 };
        }

        function generateNineCircles(canvasHeight) {
            const obstacles = [];
            const groundH = 30;
            const playableHeight = canvasHeight - groundH;
            let x = 600;

            for (let i = 0; i < 5; i++) {
                const gapCenter = playableHeight * 0.5 + Math.sin(i * 0.8) * 80;
                const gapSize = 95;
                obstacles.push({ x, y: 0, w: 100, h: gapCenter - gapSize/2, type: 'nc' });
                obstacles.push({ x, y: gapCenter + gapSize/2, w: 100, h: playableHeight - (gapCenter + gapSize/2), type: 'nc' });
                x += 180;
            }

            for (let i = 0; i < 8; i++) {
                if (i % 2 === 0) {
                    obstacles.push({ x, y: 0, w: 60, h: 140, type: 'nc' });
                    obstacles.push({ x: x + 30, y: playableHeight - 60, w: 60, h: 60, type: 'spike', direction: 'up' });
                } else {
                    obstacles.push({ x, y: playableHeight - 140, w: 60, h: 140, type: 'nc' });
                    obstacles.push({ x: x + 30, y: 0, w: 60, h: 60, type: 'spike', direction: 'down' });
                }
                x += 150;
            }

            for (let i = 0; i < 12; i++) {
                const gapY = 80 + (i % 3) * 80;
                const gapSize = 85;
                obstacles.push({ x, y: 0, w: 80, h: gapY, type: 'nc' });
                obstacles.push({ x, y: gapY + gapSize, w: 80, h: playableHeight - gapY - gapSize, type: 'nc' });
                x += 120;
            }

            for (let i = 0; i < 6; i++) {
                const wave = Math.sin(i * 1.2) * 60;
                const centerY = playableHeight * 0.5 + wave;
                const gapSize = 80;
                obstacles.push({ x, y: 0, w: 120, h: centerY - gapSize/2, type: 'nc' });
                obstacles.push({ x, y: centerY + gapSize/2, w: 120, h: playableHeight - (centerY + gapSize/2), type: 'nc' });
                x += 160;
            }

            return { obstacles, length: x + 300 };
        }

        function generateSonicWave(canvasHeight) {
            const obstacles = [];
            const groundH = 30;
            const playableHeight = canvasHeight - groundH;
            let x = 600;

            for (let i = 0; i < 6; i++) {
                const centerY = playableHeight * 0.5 + Math.sin(i * 0.6) * 100;
                const gapSize = 75;
                obstacles.push({ x, y: 0, w: 80, h: centerY - gapSize/2, type: 'sonic' });
                obstacles.push({ x, y: centerY + gapSize/2, w: 80, h: playableHeight - (centerY + gapSize/2), type: 'sonic' });
                x += 140;
            }

            for (let i = 0; i < 10; i++) {
                const baseY = i % 2 === 0 ? 0 : playableHeight - 50;
                obstacles.push({ x, y: baseY, w: 50, h: 50, type: 'spike', direction: i % 2 === 0 ? 'down' : 'up' });
                if (i % 2 === 0) {
                    obstacles.push({ x: x - 20, y: playableHeight - 100, w: 90, h: 100, type: 'sonic' });
                } else {
                    obstacles.push({ x: x - 20, y: 0, w: 90, h: 100, type: 'sonic' });
                }
                x += 100;
            }

            for (let i = 0; i < 8; i++) {
                const phase = i * 0.7;
                const centerY = playableHeight * 0.5 + Math.sin(phase) * 80;
                const gapSize = 70;
                obstacles.push({ x, y: 0, w: 60, h: centerY - gapSize/2, type: 'sonic' });
                obstacles.push({ x, y: centerY + gapSize/2, w: 60, h: playableHeight - (centerY + gapSize/2), type: 'sonic' });
                x += 100;
            }

            for (let i = 0; i < 12; i++) {
                const zigzag = (i % 2 === 0) ? 70 : playableHeight - 145;
                const gapSize = 75;
                obstacles.push({ x, y: 0, w: 70, h: zigzag, type: 'sonic' });
                obstacles.push({ x, y: zigzag + gapSize, w: 70, h: playableHeight - zigzag - gapSize, type: 'sonic' });
                x += 110;
            }

            return { obstacles, length: x + 300 };
        }

        function generateBloodbath(canvasHeight) {
            const obstacles = [];
            const groundH = 30;
            const playableHeight = canvasHeight - groundH;
            let x = 600;

            for (let i = 0; i < 8; i++) {
                const offset = Math.sin(i * 0.8) * 60;
                const centerY = playableHeight * 0.5 + offset;
                const gapSize = 80;
                obstacles.push({ x, y: 0, w: 90, h: centerY - gapSize/2, type: 'blood' });
                obstacles.push({ x, y: centerY + gapSize/2, w: 90, h: playableHeight - (centerY + gapSize/2), type: 'blood' });
                if (i % 3 === 0) {
                    obstacles.push({ x: x + 30, y: centerY - 15, w: 30, h: 30, type: 'spike', direction: 'none' });
                }
                x += 150;
            }

            for (let i = 0; i < 10; i++) {
                const topSpike = i % 2 === 0;
                if (topSpike) {
                    obstacles.push({ x, y: 0, w: 40, h: 60, type: 'spike', direction: 'down' });
                    obstacles.push({ x, y: playableHeight - 120, w: 80, h: 120, type: 'blood' });
                } else {
                    obstacles.push({ x, y: playableHeight - 60, w: 40, h: 60, type: 'spike', direction: 'up' });
                    obstacles.push({ x, y: 0, w: 80, h: 120, type: 'blood' });
                }
                x += 100;
            }

            for (let i = 0; i < 10; i++) {
                const wave = Math.sin(i * 1.5) * 70;
                const centerY = playableHeight * 0.5 + wave;
                const gapSize = 70;
                obstacles.push({ x, y: 0, w: 70, h: centerY - gapSize/2, type: 'blood' });
                obstacles.push({ x, y: centerY + gapSize/2, w: 70, h: playableHeight - (centerY + gapSize/2), type: 'blood' });
                x += 100;
            }

            return { obstacles, length: x + 300 };
        }

        function generateSakupen(canvasHeight) {
            const obstacles = [];
            const groundH = 30;
            const playableHeight = canvasHeight - groundH;
            let x = 600;

            for (let i = 0; i < 10; i++) {
                const wave = Math.sin(i * 0.9) * 90;
                const centerY = playableHeight * 0.5 + wave;
                const gapSize = 65;
                obstacles.push({ x, y: 0, w: 60, h: centerY - gapSize/2, type: 'sakupen' });
                obstacles.push({ x, y: centerY + gapSize/2, w: 60, h: playableHeight - (centerY + gapSize/2), type: 'sakupen' });
                x += 90;
            }

            for (let i = 0; i < 15; i++) {
                const fromTop = i % 3 !== 2;
                if (fromTop) {
                    obstacles.push({ x, y: 0, w: 35, h: 45 + (i % 3) * 30, type: 'spike', direction: 'down' });
                } else {
                    obstacles.push({ x, y: playableHeight - 45 - (i % 2) * 30, w: 35, h: 45 + (i % 2) * 30, type: 'spike', direction: 'up' });
                }
                x += 70;
            }

            for (let i = 0; i < 8; i++) {
                const wave1 = Math.sin(i * 1.2) * 50;
                const centerY = playableHeight * 0.4 + wave1;
                const gapSize = 60;
                obstacles.push({ x, y: 0, w: 50, h: centerY - gapSize/2, type: 'sakupen' });
                obstacles.push({ x, y: centerY + gapSize/2, w: 50, h: 60, type: 'sakupen' });
                obstacles.push({ x, y: playableHeight - 80, w: 50, h: 80, type: 'sakupen' });
                x += 85;
            }

            for (let i = 0; i < 12; i++) {
                const zigzag = i % 2 === 0 ? 60 : playableHeight - 125;
                const gapSize = 65;
                obstacles.push({ x, y: 0, w: 55, h: zigzag, type: 'sakupen' });
                obstacles.push({ x, y: zigzag + gapSize, w: 55, h: playableHeight - zigzag - gapSize, type: 'sakupen' });
                x += 80;
            }

            return { obstacles, length: x + 300 };
        }

        // ============ GAME STATE ============
        let currentLevel = null;
        let gameState = 'menu';
        let attempts = 1;
        let bestProgress = {};

        try {
            bestProgress = JSON.parse(localStorage.getItem('gdWaveProgress')) || {};
        } catch(e) { bestProgress = {}; }

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 40, 900);
            const maxHeight = Math.min(window.innerHeight - 200, 500);
            canvas.width = maxWidth;
            canvas.height = maxHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ============ GD-ACCURATE WAVE PHYSICS ============
        // In GD, the wave moves at exactly 45 degrees
        // Hitbox is an elongated rectangle (15√ó60 in GD, scaled here)
        // The wave has NO acceleration - instant direction change

        const WAVE_HITBOX_WIDTH = 10;   // Narrow (collision width)
        const WAVE_HITBOX_HEIGHT = 45;  // Tall (collision height)
        const WAVE_VISUAL_SIZE = 28;    // Visual triangle size

        let wave = {
            x: 100,
            y: 0,
            holding: false
        };

        let obstacles = [];
        let levelLength = 0;
        let cameraX = 0;
        let gameSpeed = 6;
        let animationId = null;
        let pulsePhase = 0;
        let trailHistory = [];

        // ============ DOM ELEMENTS ============
        const menuScreen = document.getElementById('menu-screen');
        const gameScreen = document.getElementById('game-screen');
        const startOverlay = document.getElementById('start-overlay');
        const resultOverlay = document.getElementById('result-overlay');
        const levelGrid = document.getElementById('level-grid');
        const progressDisplay = document.getElementById('progress-display');
        const progressFill = document.getElementById('progress-fill');
        const attemptsDisplay = document.getElementById('attempts');
        const levelNameDisplay = document.getElementById('level-name-display');
        const startLevelName = document.getElementById('start-level-name');
        const resultTitle = document.getElementById('result-title');
        const resultProgress = document.getElementById('result-progress');
        const resultAttempts = document.getElementById('result-attempts');

        // ============ LEVEL GRID ============
        function renderLevelGrid() {
            levelGrid.innerHTML = '';

            LEVELS.forEach((level) => {
                const card = document.createElement('div');
                card.className = 'level-card';
                card.style.setProperty('--level-color', level.color);

                let stars = '';
                for (let i = 0; i < 5; i++) {
                    stars += `<div class="star ${i < level.difficulty ? '' : 'empty'}"></div>`;
                }

                const best = bestProgress[level.id] || 0;

                card.innerHTML = `
                    <div class="level-name">${level.name}</div>
                    <div class="level-difficulty">${stars}</div>
                    <div class="level-desc">${level.desc}</div>
                    <div class="level-best">Best: <span>${best}%</span></div>
                `;

                card.addEventListener('click', () => {
                    playSound('click');
                    startLevel(level);
                });
                levelGrid.appendChild(card);
            });
        }
        renderLevelGrid();

        // ============ GAME FUNCTIONS ============
        function showScreen(screen) {
            [menuScreen, gameScreen].forEach(s => s.classList.remove('active'));
            screen.classList.add('active');
        }

        function startLevel(level) {
            currentLevel = level;
            gameSpeed = level.speed;
            attempts = 1;

            const generated = level.generateObstacles(canvas.height);
            obstacles = generated.obstacles;
            levelLength = generated.length;

            resetWave();

            startLevelName.textContent = level.name;
            startLevelName.style.color = level.color;
            startLevelName.style.textShadow = `0 0 20px ${level.color}`;
            levelNameDisplay.textContent = level.name;
            attemptsDisplay.textContent = `Attempt ${attempts}`;

            showScreen(gameScreen);
            startOverlay.classList.remove('hidden');
            resultOverlay.classList.remove('active');
            gameState = 'ready';

            draw();
        }

        function resetWave() {
            wave.x = 100;
            wave.y = canvas.height / 2;
            wave.holding = false;
            cameraX = 0;
            trailHistory = [];
        }

        function beginGame() {
            if (gameState !== 'ready') return;
            gameState = 'playing';
            startOverlay.classList.add('hidden');

            // Start music
            if (soundEnabled) {
                sounds.music.currentTime = 0;
                sounds.music.play().catch(() => {});
            }

            gameLoop();
        }

        function gameLoop() {
            if (gameState !== 'playing') return;

            update();
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }

        function update() {
            // ============ GD-ACCURATE WAVE PHYSICS ============
            // Wave moves at EXACTLY 45 degrees - no acceleration, no gravity
            // Horizontal speed = vertical speed (this creates 45 degree movement)
            // Direction changes INSTANTLY when you press/release

            const diagonalSpeed = gameSpeed;

            // Move wave vertically based on input (instant direction change like GD)
            if (wave.holding) {
                wave.y -= diagonalSpeed; // Go up at 45 degrees
            } else {
                wave.y += diagonalSpeed; // Go down at 45 degrees
            }

            // Move camera (this creates the forward movement)
            cameraX += gameSpeed;

            // Store trail position
            trailHistory.unshift({ x: wave.x, y: wave.y, holding: wave.holding });
            if (trailHistory.length > 15) trailHistory.pop();

            // Update progress
            const progress = Math.min(100, Math.floor((cameraX / (levelLength - canvas.width)) * 100));
            progressDisplay.textContent = `${progress}%`;
            progressFill.style.width = `${progress}%`;

            // Check boundaries (ground and ceiling)
            const groundY = canvas.height - 30;
            if (wave.y - WAVE_HITBOX_HEIGHT/2 < 0 || wave.y + WAVE_HITBOX_HEIGHT/2 > groundY) {
                die(progress);
                return;
            }

            // Check collisions with obstacles using accurate rectangular hitbox
            for (const obs of obstacles) {
                if (checkCollision(wave, obs, cameraX)) {
                    die(progress);
                    return;
                }
            }

            // Check win condition
            if (cameraX >= levelLength - canvas.width) {
                win();
            }

            pulsePhase += 0.1;
        }

        // GD-Accurate rectangular hitbox collision (15√ó60 aspect ratio)
        function checkCollision(wave, obs, camX) {
            // Wave hitbox - elongated rectangle like in real GD
            const waveLeft = wave.x - WAVE_HITBOX_WIDTH/2;
            const waveRight = wave.x + WAVE_HITBOX_WIDTH/2;
            const waveTop = wave.y - WAVE_HITBOX_HEIGHT/2;
            const waveBottom = wave.y + WAVE_HITBOX_HEIGHT/2;

            // Obstacle position relative to screen
            const obsLeft = obs.x - camX;
            const obsRight = obsLeft + obs.w;
            const obsTop = obs.y;
            const obsBottom = obs.y + obs.h;

            // Skip if obstacle is off-screen
            if (obsRight < -50 || obsLeft > canvas.width + 50) return false;

            // AABB collision check
            return waveRight > obsLeft &&
                   waveLeft < obsRight &&
                   waveBottom > obsTop &&
                   waveTop < obsBottom;
        }

        function die(progress) {
            gameState = 'dead';
            cancelAnimationFrame(animationId);

            // Stop music, play death sound
            sounds.music.pause();
            playSound('death');

            if (!bestProgress[currentLevel.id] || progress > bestProgress[currentLevel.id]) {
                bestProgress[currentLevel.id] = progress;
                localStorage.setItem('gdWaveProgress', JSON.stringify(bestProgress));
            }

            resultTitle.textContent = 'Level Failed';
            resultTitle.className = 'result-title fail';
            resultProgress.textContent = `${progress}%`;
            resultAttempts.textContent = attempts;
            resultOverlay.classList.add('active');
        }

        function win() {
            gameState = 'complete';
            cancelAnimationFrame(animationId);

            sounds.music.pause();
            playSound('complete');

            bestProgress[currentLevel.id] = 100;
            localStorage.setItem('gdWaveProgress', JSON.stringify(bestProgress));

            resultTitle.textContent = 'Level Complete!';
            resultTitle.className = 'result-title complete';
            resultProgress.textContent = '100%';
            resultAttempts.textContent = attempts;
            resultOverlay.classList.add('active');

            renderLevelGrid();
        }

        function retry() {
            playSound('click');
            attempts++;
            attemptsDisplay.textContent = `Attempt ${attempts}`;
            resetWave();
            resultOverlay.classList.remove('active');
            startOverlay.classList.remove('hidden');
            gameState = 'ready';
            draw();
        }

        function goToMenu() {
            playSound('click');
            gameState = 'menu';
            cancelAnimationFrame(animationId);
            sounds.music.pause();
            resultOverlay.classList.remove('active');
            showScreen(menuScreen);
            renderLevelGrid();
        }

        // ============ DRAWING ============
        function draw() {
            const levelColor = currentLevel ? currentLevel.color : '#00ffff';

            // Dark background
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pulsing glow effect (Nine Circles style)
            const pulse = Math.sin(pulsePhase) * 0.3 + 0.7;
            ctx.fillStyle = hexToRgba(levelColor, 0.04 * pulse);
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid lines
            ctx.strokeStyle = hexToRgba(levelColor, 0.08);
            ctx.lineWidth = 1;
            const gridSize = 50;
            const offsetX = -(cameraX % gridSize);

            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw obstacles
            for (const obs of obstacles) {
                const screenX = obs.x - cameraX;
                if (screenX > -obs.w && screenX < canvas.width + 100) {
                    drawObstacle(obs, screenX, levelColor);
                }
            }

            // Ground
            const groundGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
            groundGradient.addColorStop(0, hexToRgba(levelColor, 0.9));
            groundGradient.addColorStop(1, hexToRgba(levelColor, 0.4));
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height - 30, canvas.width, 30);

            // Ground line glow
            ctx.shadowColor = levelColor;
            ctx.shadowBlur = 10;
            ctx.strokeStyle = levelColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 30);
            ctx.lineTo(canvas.width, canvas.height - 30);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Ceiling line
            ctx.strokeStyle = hexToRgba(levelColor, 0.5);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 2);
            ctx.lineTo(canvas.width, 2);
            ctx.stroke();

            // Draw wave trail
            drawTrail(levelColor);

            // Draw wave
            drawWave(levelColor);
        }

        function drawObstacle(obs, screenX, levelColor) {
            const obsColor = getObstacleColor(obs.type, levelColor);

            if (obs.type === 'spike') {
                ctx.fillStyle = obsColor;
                ctx.beginPath();

                if (obs.direction === 'up') {
                    ctx.moveTo(screenX, obs.y + obs.h);
                    ctx.lineTo(screenX + obs.w/2, obs.y);
                    ctx.lineTo(screenX + obs.w, obs.y + obs.h);
                } else if (obs.direction === 'down') {
                    ctx.moveTo(screenX, obs.y);
                    ctx.lineTo(screenX + obs.w/2, obs.y + obs.h);
                    ctx.lineTo(screenX + obs.w, obs.y);
                } else {
                    ctx.moveTo(screenX + obs.w/2, obs.y);
                    ctx.lineTo(screenX + obs.w, obs.y + obs.h/2);
                    ctx.lineTo(screenX + obs.w/2, obs.y + obs.h);
                    ctx.lineTo(screenX, obs.y + obs.h/2);
                }
                ctx.closePath();
                ctx.fill();

                ctx.shadowColor = obsColor;
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = obsColor;
                ctx.fillRect(screenX, obs.y, obs.w, obs.h);

                ctx.strokeStyle = hexToRgba('#fff', 0.2);
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX + 2, obs.y + 2, obs.w - 4, obs.h - 4);

                ctx.shadowColor = obsColor;
                ctx.shadowBlur = 20;
                ctx.strokeStyle = obsColor;
                ctx.strokeRect(screenX, obs.y, obs.w, obs.h);
                ctx.shadowBlur = 0;
            }
        }

        function getObstacleColor(type, levelColor) {
            switch(type) {
                case 'nc': return '#ff00ff';
                case 'sonic': return '#00aaff';
                case 'blood': return '#ff4444';
                case 'sakupen': return '#ff0088';
                case 'spike': return levelColor;
                default: return levelColor;
            }
        }

        function drawTrail(levelColor) {
            for (let i = 0; i < trailHistory.length; i++) {
                const t = trailHistory[i];
                const alpha = (1 - i / trailHistory.length) * 0.5;
                const size = WAVE_VISUAL_SIZE * (1 - i / trailHistory.length * 0.5);

                ctx.save();
                ctx.translate(t.x - i * 4, t.y);
                ctx.rotate(t.holding ? -Math.PI/4 : Math.PI/4);

                ctx.fillStyle = hexToRgba(levelColor, alpha * 0.3);
                ctx.beginPath();
                ctx.moveTo(size/2, 0);
                ctx.lineTo(-size/2, -size/2);
                ctx.lineTo(-size/3, 0);
                ctx.lineTo(-size/2, size/2);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
        }

        function drawWave(levelColor) {
            ctx.save();
            ctx.translate(wave.x, wave.y);

            // Rotation: 45 degrees based on direction
            const rotation = wave.holding ? -Math.PI/4 : Math.PI/4;
            ctx.rotate(rotation);

            // Glow effect
            ctx.shadowColor = levelColor;
            ctx.shadowBlur = 25;

            // Wave shape (arrow/chevron pointing right)
            ctx.fillStyle = levelColor;
            ctx.beginPath();
            ctx.moveTo(WAVE_VISUAL_SIZE/2, 0);
            ctx.lineTo(-WAVE_VISUAL_SIZE/2, -WAVE_VISUAL_SIZE/2);
            ctx.lineTo(-WAVE_VISUAL_SIZE/3, 0);
            ctx.lineTo(-WAVE_VISUAL_SIZE/2, WAVE_VISUAL_SIZE/2);
            ctx.closePath();
            ctx.fill();

            // Inner highlight
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.moveTo(WAVE_VISUAL_SIZE/4, 0);
            ctx.lineTo(-WAVE_VISUAL_SIZE/4, -WAVE_VISUAL_SIZE/4);
            ctx.lineTo(-WAVE_VISUAL_SIZE/6, 0);
            ctx.lineTo(-WAVE_VISUAL_SIZE/4, WAVE_VISUAL_SIZE/4);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // ============ CONTROLS ============
        function handlePress() {
            if (gameState === 'ready') {
                beginGame();
            }
            wave.holding = true;
        }

        function handleRelease() {
            wave.holding = false;
        }

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.key === ' ' || e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                e.preventDefault();
                handlePress();
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' || e.key === ' ' || e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                handleRelease();
            }
        });

        // Mouse
        canvas.addEventListener('mousedown', handlePress);
        canvas.addEventListener('mouseup', handleRelease);
        canvas.addEventListener('mouseleave', handleRelease);

        // Touch
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handlePress();
        });
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleRelease();
        });

        // Start overlay
        startOverlay.addEventListener('mousedown', handlePress);
        startOverlay.addEventListener('mouseup', handleRelease);
        startOverlay.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handlePress();
        });
        startOverlay.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleRelease();
        });

        // Buttons
        document.getElementById('retry-btn').addEventListener('click', retry);
        document.getElementById('menu-btn').addEventListener('click', goToMenu);
    </script>
</body>
</html>
